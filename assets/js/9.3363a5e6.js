(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{182:function(e,a,r){"use strict";r.r(a);var t=r(0),i=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"问答方式学-node-js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#问答方式学-node-js","aria-hidden":"true"}},[e._v("#")]),e._v(" 问答方式学 Node.js")]),e._v(" "),r("h2",{attrs:{id:"q-什么是-node-js-？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q-什么是-node-js-？","aria-hidden":"true"}},[e._v("#")]),e._v(" Q: 什么是 Node.js ？")]),e._v(" "),r("p",[e._v("A：Node.js 是指运于 web 服务端的 JavaScript，基于 Chrome V8 引擎，有非阻塞，事件驱动 I/O 等特性。")]),e._v(" "),r("h2",{attrs:{id:"q-等等，你刚提到了-chrome-v8-引擎，它是什么，为什么使用它而不是其它引擎？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q-等等，你刚提到了-chrome-v8-引擎，它是什么，为什么使用它而不是其它引擎？","aria-hidden":"true"}},[e._v("#")]),e._v(" Q: 等等，你刚提到了 Chrome V8 引擎，它是什么，为什么使用它而不是其它引擎？")]),e._v(" "),r("p",[e._v("A：JavaScript 引擎是执行 JavaScript 代码的程序或解释器，JavaScript 引擎可以实现为标准解释器，或者以某种形式将 JavaScript 编译为字节码的即时编译器。它的工作流程大致如下：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb451e71d9ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),r("p",[e._v("Chrome V8 引擎便是其中一种，由 Google 开发，使用 C++ 编写，它的工作流程几乎与上图一致：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb452d3fccab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),r("p",[e._v("相比于其它 JavaScript 引擎转换成字节码或者解释执行，V8 将 JavaScript 代码转换成更高效的机器码（IA-32, x86-64, ARM, or MIPS CPUs）。它通过 JIT（Just-In-Time）编译器实现，不生成字节码或任何中间代码。并且使用了如 Inlining、Shapes、Inline Caches 等方法来提高性能。")]),e._v(" "),r("h2",{attrs:{id:"q：很好，现在我已经了解一点-chrome-v8-引擎有什么用了，但是你列举的那些方法，真让我头大。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q：很好，现在我已经了解一点-chrome-v8-引擎有什么用了，但是你列举的那些方法，真让我头大。","aria-hidden":"true"}},[e._v("#")]),e._v(" Q：很好，现在我已经了解一点 Chrome V8 引擎有什么用了，但是你列举的那些方法，真让我头大。")]),e._v(" "),r("p",[e._v("A：比如 Shapes 与 Inline Caches 用来优化对象属性加载。")]),e._v(" "),r("p",[e._v("Q：嗯？")]),e._v(" "),r("p",[e._v("A：ECMAScript 规范基本上将所有对象定义为由字符串键值映射到 property 属性的字典，其中 "),r("code",[e._v("[[]]")]),e._v(" 双方括号是规范定义不能直接暴露给 JavaScript 的属性的表示方法。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb457ff3681e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),r("h2",{attrs:{id:"q：在内存中也是这么存储？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q：在内存中也是这么存储？","aria-hidden":"true"}},[e._v("#")]),e._v(" Q：在内存中也是这么存储？")]),e._v(" "),r("p",[e._v("A：不不不，如果在内存中这么存储，那就浪费空间了。比如说有相同形状的对象 "),r("code",[e._v("object = { x: 7, y: 8 }")]),e._v("，它们的属性名是相同的，并且在属性值的完整字典中，也只有 "),r("code",[e._v("[[value]]")]),e._v(" 不同。")]),e._v(" "),r("h2",{attrs:{id:"q：那应该分开存储，把除-value-之外的所有属性名和其余特性单独存储。并且它需要有一个属性，来告知-javascript-引擎去哪查找具体的值。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q：那应该分开存储，把除-value-之外的所有属性名和其余特性单独存储。并且它需要有一个属性，来告知-javascript-引擎去哪查找具体的值。","aria-hidden":"true"}},[e._v("#")]),e._v(" Q：那应该分开存储，把除 "),r("code",[e._v("[[value]]")]),e._v(" 之外的所有属性名和其余特性单独存储。并且它需要有一个属性，来告知 JavaScript 引擎去哪查找具体的值。")]),e._v(" "),r("p",[e._v("A：是的，引擎将对象的 "),r("code",[e._v("Shape")]),e._v(" 分开存储，如下 JSObject 只是存储 "),r("code",[e._v("[[value]]")]),e._v("，"),r("code",[e._v("Shape")]),e._v(" 中有一个 "),r("code",[e._v("Offset")]),e._v(" 偏移量来告知 JavaScript 取哪找具体的值：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb452af595b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),r("p",[e._v("当有多个具有相同形状对象时，优势变得清晰可见。因为只需要将它们的形状与键值属性信息存储一次！")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb45ccfca9a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),r("h2",{attrs:{id:"q：原来是这样，不过那和-inline-caches-有什么关系？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q：原来是这样，不过那和-inline-caches-有什么关系？","aria-hidden":"true"}},[e._v("#")]),e._v(" Q：原来是这样，不过那和 Inline Caches 有什么关系？")]),e._v(" "),r("p",[e._v("A：关系大了，Shapes 主要是用来实现 Inline Caches（ICs）的，Inline Caches 是 JavaScript 快速运行的关键因素之一。")]),e._v(" "),r("p",[e._v("Q："),r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb45397ad788?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),r("p",[e._v("A：比如有一个从对象中获取 x 属性的函数，在 JSC（JavaScriptCore） 中执行时，会生成以下字节码：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb458131f03d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),e._v(" "),r("p",[e._v("Inline Caches 在第一个指令 "),r("code",[e._v("get_by_id")]),e._v(" 指令中，由两个未初始化的插槽组成。")]),e._v(" "),r("p",[e._v("当调用函数 "),r("code",[e._v("getX({ x: 'a' })")]),e._v(" 时，像前面所说，对象 "),r("code",[e._v("{ x: 'a' }")]),e._v(" 有一个包含属性 "),r("code",[e._v("x")]),e._v(" 的 Shape，该 Shape 包含属性 x 的偏移量和其它特性，当第一次执行该函数时，会把该属性的 Shape 和 偏移量存储在 Inline Caches 中：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb45b406c425?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),r("p",[e._v("后续调用该函数时，Inline Caches 只需要对比 Shape，如果与以前相同，则只需要从偏移量加载该属性值。这比每次查找要快很多。")]),e._v(" "),r("p",[e._v("Q：很精彩！")]),e._v(" "),r("p",[e._v("A：V8 所做的，远不止这些，在即将要发布的 7.2 版本中，解析时间明显降低，缩短加载时间，提高响应速度：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/27/167efb45c3b90dc5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:"img"}})]),e._v(" "),r("h2",{attrs:{id:"q：好了，咱们不说-v8-了，我对你前面提到的非阻塞和事件驱动-i-o-挺感兴趣的。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#q：好了，咱们不说-v8-了，我对你前面提到的非阻塞和事件驱动-i-o-挺感兴趣的。","aria-hidden":"true"}},[e._v("#")]),e._v(" Q：好了，咱们不说 V8 了，我对你前面提到的非阻塞和事件驱动 I/O 挺感兴趣的。")]),e._v(" "),r("p",[e._v("A：......")])])}],!1,null,null,null);a.default=i.exports}}]);